0. REDUX, REDUX-SAGA 차이
1) REDUX
=> LOG_IN 액션 바로실행
=> 동기 동작

2) REDUX-SAGA
=> LOG_IN이라는 액션이 실행되는지 대기하고있다가 액션 실행되면 동작 
=> 비동기 동작, SUCCESS 또는 FAILURE 실행


1. 로그인
=> 과정
-> 서버쪽에 data가 전달되고,
-> 서버가 로그인 성공이라는 응답을 보내주고
-> 그걸 다시받아서 로그인

=> 로그인 동작 과정
-> 서버에 요청을 보낸다 - request
-> 결과가 로그인 성공, 로그인 실패
-> 요청과 결과사이가 비동기

2. 제너레이터
=> 함수 실행을 중간에 멈출 수 있고 원할 재개
=> 예시
function* genartor(){

}

3. redux-saga 구조
0) saga폴더
1) rootSaga - 여러 saga를 연결해줌(index.js)
import { all, call } from 'redux-saga/effects';
import user from './user';
import post from './post';

export default function* rootSaga(){
	yield all ([
		// call - 함수 동기적 호출
		call(user),
		call(post),
	])
}

2) user.js
import { all, fork, takeLatest, call, put } from 'redux-saga/effects';
import { LOG_IN, LOG_IN_SUCCESS, LOG_IN_FAILRE } from '../reducers/user';

function loginAPI() {
	//서버에 요청을 보내는 부분
}

function* login() {
	try {
		yield call(loginAPI)
		//put은 액션 dispatch와 동일 - 액션 실행
		yield put({
			type: LOG_IN_SUCCESS
		})

	} catch (e) {// loginAPI 실패
		console.error(e);
		yield put({
			type: LOG_IN_FAILRE
		})
	}
}

function* watchLogin() {
	//takeLatest - LOG_IN이면 login실행
	yield takeLatest(LOG_IN, login)
}

export default function* userSaga(){
	yield all([
		// fork - 함수 비동기적 호출
		fork(watchLogin),
	]);
}

3) post.js


4. saga Middleware
=>saga Middleware를 별도의 파일을 만들면X
1) saga Middleware 만들기
import createSagaMiddleware from 'redux-saga';

const sagaMiddleware = createSagaMiddleware();

2) saga Middleware 실행
=> run메서드 사용
sagaMiddleware.run(rootSaga)

3) 적용
export default withRedux((initalState, options) => { 
	const middleware = [sagaMiddleware];
	const enhancer = process.env.NODE_ENV === 'production'
	?
	compose(
		applyMIddleware(
			firstMiddleware,
			thunkMiddleware,
		)
	)
	: composeWithDevTools(
		applyMIddleware(
			firstMiddleware,
			thunkMiddleware,
		)
	)
	const store = createStore(reducer, initialState, enhancer);
	sagaMiddleware.run(rootSaga);
	return store;
})

5. hoc(Component);
=> 고차 컴포넌트(HOC, Higher Order Component)
=> 컴포넌트 로직을 재사용
=> 재사용하면서 props를 추가하는 기능
const hoc = (Component) => () => {
	console.log("I'm hoc")
	return(
		<Component hello="I'm hoc" />
	)
}
-> 위에서 일반함수 컴포넌트 구간 
() => {

}
-> (Component) - 재사용 컴포넌트에 덮어 쓸 수 있음
-> hello="I'm hoc" - props 추가 가능
-> console.log("I'm hoc") - 중간에 기록용 가능

6. connect(mapStateProps)(Component)
=> 예시
const connect = (mapStateProps) => (Component) => () => {
	console.log("I'm hoc")
	return(
		<Component props={mapStateProps()} />
	)
}
=> 기능이 여러개일경우 계속 늘어남
=> connect(기능1)(기능2)(Component)

7. 제너레이터
function* generator(){
	yield* [1,2,3,4]
}
=> yield* 반복(반복가능한 값)
=> 한번실행하면 반복이 안됨, 반복하려면 반복문 안에 있어야함

8. redux-saga
1) take
=> 예시1 
-> 해당 액션이 dispatch되면 제너레이터를 next하는 이펙트
import { take } from 'redux-saga/effects'
function* generator(){
	yield take(dispatchType)
}
-> 컴포넌트에서 직접 dispatch

=> 예시2
function* generator(){
	while(true){
		yield take(dispatchType)
		yield put({
			type: LOG_INSUCCESS
		})
	}
}
-> dispatchType 액션이 실행되고나서, LOG_INSUCCESS 액션 실행

2) 무한반복
=> while문 사용
=> 로그인, 로그아웃에서 사용
function* helloSaga(){
	while(true){
		yield take(dispatchType)
		console.log('hello saga')
	}
}

3) all 
=> 여러 함수를 같이 실행시킴
import { all } from 'redux-saga/effects'
export default function* userSaga(){
	yield all([
		watchHello(),
		watchLogin(),
		watchSignUp()
	])
}

4) delay
=> 지연 시키기
import { delay } from 'redux-saga/effects'
function* helloSaga(){
	while(true){
		yield take(dispatchType)
		yield delay(2000)
		console.log('hello saga')
	}
}


5) takeLatest
import { takeLatest } from 'redux-saga/effects'
=> while문을 숨길수 있음
function* helloSaga(){
	yield takeLatest(dispatchType, function*(){
		동작
	})
}
=> delay를 주면 동작을 한번만 함
=> 비동기에서 씀
=> 여러번 동시에 dispatch하면 마지막꺼를 실행을 기점으로 동작이 한번만 실행됨
=> 이전요청이 끝나지 않은게 있다면 이전요청을 취소함
=> 버튼을 여러번 잘못눌러서 한번만 실행되게 할때 사용

6) takeEvery
import { takeEvery } from 'redux-saga/effects'
=> while문을 숨길수 있음
function* 함수명(){
		동작
	}
function* helloSaga(){
	yield takeEvery(dispatchType, 함수명)
}
-> while문 쓴거랑 같음, 반복할때 사용

7) fork
=> 함수를 실행
=> 비동기 호출
=> 함수실행 순서가 상관이 없을때
=> all쓰고 watch일경우 fork 사용
import { all, fork } from 'redux-saga/effects'
expoty default function* userSaga() {
	yield all([
		fork(watchLogin),
		fork(watchHello),
	])
}

8) call
=> 함수를 실행
=> 동기 호출
=> 순서를 지켜서 함수를 실행할때는 call을 써야함
=> 응답이 다 받아질때까지 기다림
=> 서버로 요청한 응답을 받아야 후에 실행됨, fork로 쓰면 응답을 못받아도 다음액션 실행
=> 예시
import { call, put } from 'redux-saga/effects'
function* login() {
	try {
		yield call(loginAPI);
		yield put({
			type: LOG_IN_SUCCESS,
		});	
	} catch (e) {
		console.error(e);
		yield put({
			type: LOG_IN_FAILURE,
		})
	}
} 

9) 그 외 잘쓰는 effects
=> race, cancel, select, throttle, debounce
