★ useState로 사용

* 버튼없이 할경우 api 연동
=> 1. 3가지 지정
-> 1) 요청의 결과
-> const [요청의 결과, set 요청의 결과] = useState(null);
-> 2) 로딩 상태
-> const [로딩 상태, set 로딩 상태] = useState(false);
-> 3) 에러
-> const [에러, set 에러] = useState(null);

=> 2. useEffect를 사용
-> 1) useEffect 작성
-> useEffect(() => { 
    }, []);
-> 2) useEffect안에 async함수 작성
-> 2-1) 요청 결과, 에러를 초기화 로딩상태를 true
-> 2-2) axios.get 데이터 조회, 데이터 set
-> 2-3) catch에 set error
-> const async함수 = async () => {
	try{
		//요청이 시작할때는 요청 결과, 에러를 초기화하고, 
		//로딩상태를 true로 바꿈
		//axios.get 데이터 조회, 데이터 set
	} catch (e) {
		//에러넣기
	}
    }
=> 3. async함수 실행

=> 4. if문을 이용해서 return 값 지정
-> 1) 로딩일 때
-> if (loading) return <div>로딩중..</div>;
-> 2) 에러일 때
-> if (error) return <div>에러가 발생했습니다</div>;
-> 3) 데이터가 없을때 
-> if (!데이터변수) return null;
-> 4) 나머지
-> return(
	html
	)

* 버튼이 있을경우
=> 1. 컴포넌트 안에 async함수를 작성 
=> 2. useEffect 안에서 async함수를 실행

-----------------------------------------------------------------------------------------------

★ useReducer를 이용한 Api 연동
=> 1. reducer 함수 작성
-> 1) 로딩일때 - 로딩만 true
->  case 'LOADING':
     return {
     	loading: true,
     	data: null,
     	error: null
     };
-> 2) 데이터 가져온 후 - action.data -> .data가 데이터의미
->  const response = await axios.get(
        'https://jsonplaceholder.typicode.com/users'
      );
      dispatch({ type: 'SUCCESS', data: response.data });
-> case 'SUCCESS':
      return {
        loading: false,
        data: action.data,
        error: null
      };
-> 3) 에러일 경우 - action.error -> 에러 의미
-> catch (e) {
      dispatch({ type: 'ERROR', error: e });
    }
-> case 'ERROR':
      return {
        loading: false,
        data: null,
        error: action.error
    };
-> 4) 일반 - 보통 에러를 씀, action.type을 불러옴
-> default:
      throw new Error(`Unhandled action type: ${action.type}`);

=> 2. async 함수 작성
-> 1) useEffect, 버튼 클릭시 재사용을 위해서, useEffect 밖에서 사용
-> 2) 로딩일때 - async 함수 바로안에 작성
-> const fetchUsers = async () => {
	//로딩일때
	dispatch({ type: 'LOADING' });
}
-> 3) 데이터 결과 - axios 작성, dispatch에 객체로 담음
-> const fetchUsers = async () => {
	try{
		const response = await axios.get(
		'https://jsonplaceholder.typicode.com/users'
      		);
      		dispatch({ type: 'SUCCESS', data: response.data });
	}
}
-> 4) 에러 담기
-> catch (e) {
      dispatch({ type: 'ERROR', error: e });
    }

=> 3. 비구조화
-> 1) state에서 꺼내기
-> 2) data를 users로 만들기 - data: users
-> const { loading, data: users, error } = state;

=> 4. useEffect안에서 async 함수실행
-> useEffect(() => {
    fetchUsers();
  }, []);

=> 5. 버튼에 이벤트 걸기
->  <button onClick={async 함수}>다시 불러오기</button>

----------------------------------------------------------------------------------------------

★ useAsync 커스텀 Hook 만들어서 사용

*js를 두개 만들기
=> 1. 첫번째 js - useAsync.js
-> 1) reducer 함수 작성
-> 2) useAsync 컴포넌트 작성
-> 2-1) 컴포넌트에 파라미터 넣기
->function useAsync(callback, deps = []) {

}
-> callback - 첫번째 파라미터는 API 요청을 시작하는 함수(API 주소)
-> deps = [] - 두번째 파라미터는 deps, useEffect 의 deps 로 설정
-> 2-2) useReduce 작성
-> 2-3) async 함수 작성 - dispatch 같이 작성
->  const fetchData = async () => {
	//로딩
    	dispatch({ type: 'LOADING' });
     try {
	//데이터
     	const data = await callback();
     	dispatch({ type: 'SUCCESS', data });
     } catch (e) {
	//에러
    	dispatch({ type: 'ERROR', error: e });
     }
  };
-> 2-4) useEffect 작성
-> useEffect(() => {
    	fetchData();
    	// eslint 설정을 다음 줄에서만 비활성화
    	// eslint-disable-next-line
  }, deps);
-> 2-5) return 값 정의 - 다른 곳에서 써야할 것을 내보냄
-> return [state, fetchData]

=> 2. 두번째 js - Users.js
-> 1) API 요청 함수 작성
async function getUsers() { 
   // useAsync 에서는 Promise 의 결과를 바로 data 에 담기 때문에,
   // 요청을 한 이후 response 에서 data 추출하여 반환하는 함수를 따로 만들었습니다.
  const response = await axios.get(
    'https://jsonplaceholder.typicode.com/users'
  );
  return response.data;
}
-> 1-1) axios는 promise를 반환하는 메서드라 함수앞에 async 사용
->use = async function(){
    let response;
    let data = await axios.get('url') // axios는 promise를 반환하는 메서드임(api get호출)
    data.then(function(res){     // promise객체는 .then().catch() 와 같이 직관적으로 다음함수 실행 가능
        response = JSON.stringify(res)
    })
    return response
}
 
console.log(use())
-> 2) 커스텀 Hook 적용 - 컴포넌트 안에 작성
-> const [state, refetch] = useAsync(API 요청 함수, []);
-> 3) 비구조화 
-> // state.data 를 users 키워드로 조회
const { loading, data: users, error } = state;

-------------------------------------------------------------------------------------------------

★ 데이터 나중에 불러오기

*js를 두개 만들기
=> 1. 첫번째 js - useAsync.js
-> 1) reducer 함수 작성
-> 2) useAsync 컴포넌트 함수 - useAsync(api매개변수, deps=[], 랜더링매개변수)
-> 3) fatch, async 함수
-> 3-1) dispatch 작성
-> try전 dispatch type 로딩
-> try안 dispatch type 데이터
-> catch안 dispatch type 에러
-> 4) useEffect 함수
-> 5) state, fatch, async 함수 반환

-> 2. 첫 렌더링에만 호출하기
-> 1) 처음에 렌더링 될 때 한번만 실행하고 싶은 경우
-> 매개변수를 넘기되, 빈 배열로 넘김
useEffect(() => {
  console.log('첫 렌더링에만 호출')
}, [])

-> 3. 두번째 Users.js
-> 1) async api 요청 함수
-> 2) 5)에서 state, fatch, async 함수 반환값
-> const [state, refetch] = useAsync(getUsers, [], true);
-> 3) 비구조화
-> const { loading, data: users, error } = state; 
-> 4) if문 이용

------------------------------------------------------------------------------------------------

★ API 에 파라미터가 필요한 경우

*js를 두개 만들기
=> 1. 첫번째 js - Users.js
-> 1) useState를 이용
-> const [userId, setUserId] = useState(null);
-> 2) setUserId에서 데이터 id값을 받음
<li
   key={user.id}
   onClick={() => setUserId(user.id)}
-> 3) 컴포넌트에서 id 값을 userId로 씀
-> {userId && <User id={userId} />}

=> 2. 두번째 js - User.js
-> 1) api요청 함수에 id를 매개변수로 받기
async function getUser(id) {}
-> 2) 컴포넌트에 id를 props로 받기
async function getUser(id) {
  const response = await axios.get(
    `https://jsonplaceholder.typicode.com/users/${id}`
  );
  return response.data;
}

-> 3) 커스텀 Hook 사용
-> id가 바뀔때마다 api요청 함수 사용
-> useAsync 커스텀 Hook에 세번째 매개변수가 없는 이유가 기본이 false여서 없음,
false여야 컨텐츠가 보임 
const [state] = useAsync(() => getUser(id), [id]);

---------------------------------------------------------------------------------------------

★ 커스텀 Hook 없이, react-async 로 요청 상태 관리하기

*첫번째 User.js
=> 1. yarn add react-async 설치
=> 2. import { useAsync } from 'react-async'; 연결

=> 3. 파라미터로 옵션 넣기  
-> 3-1) 예시
-> const { data, error, isLoading } = useAsync({ promiseFn: 호출 할 함수, customerId: 커스텀 아이디, watch: promiseFn 에 넣은 함수를 다시 호출할 조건 })
-> 3-2) 예제
-> function User({ id }) {
    const { data: user, error, isLoading } = useAsync({
    promiseFn: getUser,
    id,
    watch: id
  });
-> watch 값에 특정 값을 넣어주면 이 값이 바뀔 때마다 promiseFn 에 넣은 함수를 다시 호출

=> 4. async 함수의 파라미터를 객체형태로 변환
-> async function getUser({ id }) {}

*Users.js
=> 1. useAsync 코드 전환 - 처음부터 데이터를 불러오기
-> const { data: users, error, isLoading, reload } = useAsync({
    promiseFn: getUsers
});
-> reload - 렌더링하는 시점부터 데이터를 불러오기

=> 2. useAsync 코드 전환 - ui에 따라 데이터 불러오기(이벤트 발생시 데이터 부르기)
-> const { data: users, error, isLoading, run } = useAsync({
    deferFn: getUsers
  });
-> 렌더링하는 시점이 아닌 사용자의 특정 인터랙션에 따라 API 를 호출
-> run과 deferFn 사용
-> if (!users) return <button onClick={run}>불러오기</button>;