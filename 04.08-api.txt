★ Context 와 함께 사용하기

*첫번째js - UsersContext.js
=> 1. Context 준비하기
-> import React, { createContext, useReducer, useContext } from 'react';

=> 2. 상태 객체 형태 준비
-> 2-1) 기본 상태 객체 - 로딩 false, 나머지 null
-> const initialState = {
	users: {
	loading: false,
	data: null,
	error: null
  },
  user: {
	loading: false,
	data: null,
	error: null
  }
};

-> 2-2) 로딩일 경우 - loading만 true
-> const loadingState = {
	loading: true,
	data: null,
	error: null
};
-> 2-3) 성공했을 경우, loading : false, data
-> const success = data => ({
  loading: false,
  data,
  error: null
});

-> 2-4) 에러일 경우 - error를 받아와서, loading은 false, error는 error
-> const error = error => ({
  loading: false,
  data: null,
  error: error
});

=> 3. useReducer를 이용해서 기본 상태 객체에 투입
-> 3-1) 로딩중일때 - 기본 상태객체에 로딩상태 객체를 덮음
-> case 'GET_USERS':
      return {
        ...state,
        users: loadingState
      };

-> 3-2) 성공했을때 - 기본 상태객체에 action.data를 가져온 성공상태 객체를 덮음
->case 'GET_USERS_SUCCESS':
      return {
        ...state,
        users: success(action.data)
      };

-> 3-3) 에러일경우 - 기본 상태객체에 action.error를 가져온 에러상태 객체를 덮음
 case 'GET_USERS_ERROR':
      return {
        ...state,
        users: error(action.error)
      };

=> 4. createContext 만들기 - State 용 Context 와 Dispatch 용 Context 따로 만들어주기
-> const UsersStateContext = createContext(null);
const UsersDispatchContext = createContext(null);

=> 5. createContext 들의 Provider 로 감싸주는 컴포넌트 만들기
->export function UsersProvider({ children }) {
  const [state, dispatch] = useReducer(usersReducer, initialState);
  return (
    <UsersStateContext.Provider value={state}>
      <UsersDispatchContext.Provider value={dispatch}>
        {children}
      </UsersDispatchContext.Provider>
    </UsersStateContext.Provider>
  );
}
->  {children} 꼭 쓰기

=> 6. State 를 쉽게 조회 할 수 있게 해주는 커스텀 Hook
-> export function useUsersState() {
  const state = useContext(UsersStateContext);
  if (!state) {
    throw new Error('Cannot find UsersProvider');
  }
  return state;
}

=> 7. Dispatch 를 쉽게 사용 할 수 있게 해주는 커스텀 Hook
-> export function useUsersDispatch() {
  const dispatch = useContext(UsersDispatchContext);
  if (!dispatch) {
    throw new Error('Cannot find UsersProvider');
  }
  return dispatch;
}

=> 8. axios 부르고, api 함수 쓰기
-> export async function getUsers(dispatch) {
  dispatch({ type: 'GET_USERS' });
  try {
    const response = await axios.get(
      'https://jsonplaceholder.typicode.com/users'
    );
    dispatch({ type: 'GET_USERS_SUCCESS', data: response.data });
  } catch (e) {
    dispatch({ type: 'GET_USERS_ERROR', error: e });
  }
}
-> 추후 함수 dispatch 파라미터를 받아와서 사용할것임

* 두번째js - App.js
=>1. Context 를 사용
-> function App() {
  return (
    <UsersProvider>
      <Users />
    </UsersProvider>
  );
}

* 세번째.js - Users.js
=> 1. Context 를 사용
-> import { useUsersState, useUsersDispatch, getUsers } from './UsersContext';
-> function Users() {
  const [userId, setUserId] = useState(null);
  const state = useUsersState();
  const dispatch = useUsersDispatch();
  const fetchData = () => {
    getUsers(dispatch);
  };
-> fetchData는 재사용, getUsers(dispatch) - 이때 여기서 dispatch넣어서 매개변수 받아옴

=> 2. 이벤트에서 fetchData 함수로 변경
-> if (!users) return <button onClick={fetchData}>불러오기</button>;

-------------------------------------------------------------------------------------------

★ 반복되는 코드를 줄이기

*api.js
=> 1. api 함수 꺼내기 - api.js로 만듬
import axios from 'axios';
export async function getUsers() {
  const response = await axios.get(
    'https://jsonplaceholder.typicode.com/users'
  );
  return response.data;
}
-> 데이터 값을 return 함

*asyncActionUtils.js
=> 1. api - dispatch 값을 따로 뺀것(성공, 에러 났을 경우)
-> 1) 파라미터로 액션의 타입 (예: GET_USER), Promise 를 만들어주는 함수 받아오기
-> export default function createAsyncDispatcher(type, promiseFn) {
=> 2. 성공, 실패에 대한 액션타입을 문자열로 준비 - 재사용을 위해 변수사용
-> const SUCCESS = `${type}_SUCCESS`;
  const ERROR = `${type}_ERROR`;
